# Conventional commit:
# feat(repo-health): add auto-close & comment; fix jq owner path; harden inputs
#
# - Idempotent issue upsert with fingerprint + hash
# - Auto-comment and close when repos become clean
# - Fix jq path for __owner in auto-close step
# - Safer defaults when triggered by cron (no inputs)
# - Small robustness improvements

name: Repo Health (Default vs Latest + Alerts w/ Auto-Close)

on:
  workflow_dispatch:
    inputs:
      owners:
        description: "Comma-separated owners (users/orgs)"
        required: false
        default: "shinedog,adriaanse-dev"
      include_archived:
        description: "Include archived repos (true/false)"
        required: false
        default: "false"
      include_forks:
        description: "Include forks (true/false)"
        required: false
        default: "true"
      only_private:
        description: "Limit to private repos (true/false)"
        required: false
        default: "false"
      stale_days:
        description: "Stale threshold in days"
        required: false
        default: "180"
      create_issues:
        description: "Create/update issues on violations (true/false)"
        required: false
        default: "true"
      fail_on_critical:
        description: "Fail the workflow if violations exist (true/false)"
        required: false
        default: "true"
      reopen_closed:
        description: "Reopen a closed matching issue (true/false)"
        required: false
        default: "true"
  schedule:
    - cron: "17 3 * * *"  # daily at 03:17 America/New_York

permissions:
  contents: read
  issues: write   # needed if you use GITHUB_TOKEN to open issues (PAT ignores this)

jobs:
  repo-health:
    runs-on: ubuntu-latest

    env:
      # Use raw inputs; fall back to defaults in the Prep step so cron runs are safe
      OWNERS_CSV: ${{ inputs.owners }}
      INC_ARCHIVED: ${{ inputs.include_archived }}
      INC_FORKS: ${{ inputs.include_forks }}
      ONLY_PRIVATE: ${{ inputs.only_private }}
      STALE_DAYS: ${{ inputs.stale_days }}
      CREATE_ISSUES: ${{ inputs.create_issues }}
      FAIL_ON_CRITICAL: ${{ inputs.fail_on_critical }}
      REOPEN_CLOSED: ${{ inputs.reopen_closed }}
      # Prefer PAT for cross-repo private visibility; falls back to GITHUB_TOKEN
      GH_TOKEN_EFFECTIVE: ${{ secrets.GH_TOKEN_RO || github.token }}

    steps:
      - name: Show tooling versions (gh, jq)
        run: |
          gh --version || true
          jq --version

      - name: Prep
        run: |
          set -euo pipefail
          mkdir -p reports/${{ github.run_id }}
          # Safe defaults when triggered by cron (inputs can be empty)
          : "${OWNERS_CSV:=shinedog,adriaanse-dev}"
          : "${INC_ARCHIVED:=false}"
          : "${INC_FORKS:=true}"
          : "${ONLY_PRIVATE:=false}"
          : "${STALE_DAYS:=180}"
          : "${CREATE_ISSUES:=true}"
          : "${FAIL_ON_CRITICAL:=true}"
          : "${REOPEN_CLOSED:=true}"
          echo "OWNERS_CSV=$OWNERS_CSV" >> "$GITHUB_ENV"
          echo "INC_ARCHIVED=$INC_ARCHIVED" >> "$GITHUB_ENV"
          echo "INC_FORKS=$INC_FORKS" >> "$GITHUB_ENV"
          echo "ONLY_PRIVATE=$ONLY_PRIVATE" >> "$GITHUB_ENV"
          echo "STALE_DAYS=$STALE_DAYS" >> "$GITHUB_ENV"
          echo "CREATE_ISSUES=$CREATE_ISSUES" >> "$GITHUB_ENV"
          echo "FAIL_ON_CRITICAL=$FAIL_ON_CRITICAL" >> "$GITHUB_ENV"
          echo "REOPEN_CLOSED=$REOPEN_CLOSED" >> "$GITHUB_ENV"

          printf "%s\n" "$OWNERS_CSV" | tr ',' '\n' | awk '{$1=$1};1' > owners.txt
          date -u +"%Y-%m-%dT%H:%M:%SZ" > reports/${{ github.run_id }}/timestamp.txt

      - name: GraphQL sweep: repositories
        env: { GH_TOKEN: ${{ env.GH_TOKEN_EFFECTIVE }} }
        run: |
          set -euo pipefail
          q_repos='
          query($owner:String!, $after:String) {
            repositoryOwner(login:$owner) {
              repositories(
                first: 100,
                after: $after,
                ownerAffiliations: [OWNER, ORGANIZATION_MEMBER, COLLABORATOR],
                orderBy: {field: NAME, direction: ASC}
              ) {
                pageInfo { hasNextPage endCursor }
                nodes {
                  name
                  isPrivate
                  isFork
                  isArchived
                  isEmpty
                  pushedAt
                  defaultBranchRef {
                    name
                    target { ... on Commit { committedDate } }
                  }
                }
              }
            }
          }'
          echo '[]' > repos_all.json
          while read -r owner; do
            [ -z "$owner" ] && continue
            cursor=""
            while :; do
              if [ -z "$cursor" ]; then
                resp=$(gh api graphql -f owner="$owner" -f query="$q_repos")
              else
                resp=$(gh api graphql -f owner="$owner" -f query="$q_repos" -f after="$cursor")
              fi
              if [ "$(jq -r '.data.repositoryOwner' <<<"$resp")" = "null" ]; then
                echo "WARN: No access to '$owner'; skipping." >&2
                break
              fi
              nodes=$(jq --arg owner "$owner" '
                .data.repositoryOwner.repositories.nodes
                | map(. + { __owner: $owner })
              ' <<<"$resp")
              jq -s '.[0] + .[1]' repos_all.json <(echo "$nodes") > t.json && mv t.json repos_all.json
              jq -r '.data.repositoryOwner.repositories.pageInfo.hasNextPage' <<<"$resp" | grep -q true || break
              cursor=$(jq -r '.data.repositoryOwner.repositories.pageInfo.endCursor' <<<"$resp")
            done
          done < owners.txt

          # Filter archived/forks/private visibility
          jq --arg incA "$INC_ARCHIVED" --arg incF "$INC_FORKS" --arg onlyP "$ONLY_PRIVATE" '
            map(select( ($incA=="true" or (.isArchived|not))
                      and ($incF=="true" or (.isFork|not))
                      and ($onlyP!="true" or .isPrivate==true) ))
          ' repos_all.json > repos_filtered.json

      - name: GraphQL sweep: latest commit across all branches per repo
        env: { GH_TOKEN: ${{ env.GH_TOKEN_EFFECTIVE }} }
        run: |
          set -euo pipefail
          q_refs='
          query($owner:String!, $name:String!, $after:String) {
            repository(owner:$owner, name:$name) {
              refs(first: 100, refPrefix: "refs/heads/", after: $after, orderBy: {field: TAG_COMMIT_DATE, direction: DESC}) {
                pageInfo { hasNextPage endCursor }
                nodes {
                  target { ... on Commit { committedDate } }
                }
              }
            }
          }'
          OUT="reports/${{ github.run_id }}/repo_commits.csv"
          echo 'owner,repo,default_branch,last_default,latest_any,diverges,private,archived,empty,pushed_at' > "$OUT"

          jq -c '.[]' repos_filtered.json | while read -r repo; do
            owner=$(jq -r '.__owner' <<<"$repo")
            name=$(jq -r '.name' <<<"$repo")
            def_branch=$(jq -r '.defaultBranchRef.name // ""' <<<"$repo")
            last_default=$(jq -r '.defaultBranchRef.target.committedDate // ""' <<<"$repo")
            private=$(jq -r '.isPrivate' <<<"$repo")
            archived=$(jq -r '.isArchived' <<<"$repo")
            empty=$(jq -r '.isEmpty' <<<"$repo")
            pushed_at=$(jq -r '.pushedAt // ""' <<<"$repo")

            echo '[]' > dates.json
            cursor=""
            while :; do
              if [ -z "$cursor" ]; then
                r=$(gh api graphql -f owner="$owner" -f name="$name" -f query="$q_refs" 2>/dev/null || true)
              else
                r=$(gh api graphql -f owner="$owner" -f name="$name" -f query="$q_refs" -f after="$cursor" 2>/dev/null || true)
              fi
              [ -z "$r" ] && break
              if [ "$(jq -r '.data.repository' <<<"$r")" = "null" ]; then break; fi
              nodes=$(jq '.data.repository.refs.nodes | map(.target.committedDate) | map(select(. != null))' <<<"$r")
              jq -s '.[0] + .[1]' dates.json <(echo "$nodes") > t.json && mv t.json dates.json
              jq -r '.data.repository.refs.pageInfo.hasNextPage' <<<"$r" | grep -q true || break
              cursor=$(jq -r '.data.repository.refs.pageInfo.endCursor' <<<"$r")
            done

            latest_any=$(jq -r 'if length>0 then sort | .[-1] else "" end' dates.json)
            if [ -z "$latest_any" ] && [ -n "$pushed_at" ]; then latest_any="$pushed_at"; fi

            diverges="false"
            if [ -n "$latest_any" ] && [ -n "$last_default" ] && [ "$latest_any" \> "$last_default" ]; then diverges="true"; fi
            if [ -z "$last_default" ] && [ -n "$latest_any" ]; then diverges="true"; fi

            printf '"%s","%s","%s","%s","%s","%s",%s,%s,%s,"%s"\n' \
              "$owner" "$name" "$def_branch" "$last_default" "$latest_any" "$diverges" "$private" "$archived" "$empty" "$pushed_at" \
              >> "$OUT"
          done

      - name: Compute stale/violations and build summary
        run: |
          set -euo pipefail
          OUT="reports/${{ github.run_id }}/repo_commits.csv"
          TS=$(cat reports/${{ github.run_id }}/timestamp.txt)

          # CSV -> JSON
          jq -R -s '
            def parse_csv:
              split("\n") | map(select(length>0)) |
              (.[0] | split(",")) as $h |
              (.[1:] | map(split(","))) |
              map( [range(0; $h|length)] as $i
                   | reduce $i[] as $j ({}; . + { ($h[$j]): .[$j] }) );
            parse_csv
          ' "$OUT" > table.json

          # evaluate rules
          jq --arg now "$TS" --argjson days ${STALE_DAYS} '
            def unq(x): x|gsub("^\"|\"$";"");
            def iso_to_secs($s): ( ($s|unq) | select(length>0) | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime );
            def stale($date):
              if ($date|unq|length)==0 then false
              else (( (iso_to_secs($now) - iso_to_secs($date)) / 86400.0 ) > $days)
              end;
            map(. + {
              owner: (.owner|unq),
              repo: (.repo|unq),
              default_branch: (.default_branch|unq),
              last_default: (.last_default|unq),
              diverges: (.diverges|unq),
              private: (.private|unq),
              archived: (.archived|unq),
              stale_default: stale(.last_default)
            })
          ' table.json > eval.json

          # violations: diverges==true OR stale_default==true
          jq '
            map(select((.diverges=="true") or (.stale_default==true))) as $v |
            { count: ($v|length), items: $v,
              ids: ($v | map("\(.owner)/\(.repo)")) }
          ' eval.json > violations.json

          # Markdown summary
          {
            echo "### Default Branch Recency & Divergence"
            echo
            echo "| Owner | Repo | Default Branch | Last Commit (Default) | Diverges | Stale(>${STALE_DAYS}d) | Private | Archived |"
            echo "|-------|------|----------------|-----------------------|----------|-----------------------|---------|----------|"
            jq -r '
              .[] | "| \(.owner) | \(.repo) | \(.default_branch) | \(.last_default) | \(.diverges) | \(.stale_default) | \(.private) | \(.archived) |"
            ' eval.json
          } > "reports/${{ github.run_id }}/summary.md"

          echo "violations=$(jq -r .count violations.json)" >> "$GITHUB_OUTPUT"

      - name: Create/Update issues on violating repos (idempotent w/ fingerprint & hash)
        if: ${{ env.CREATE_ISSUES == 'true' }}
        env:
          GH_TOKEN: ${{ env.GH_TOKEN_EFFECTIVE }}
        run: |
          set -euo pipefail

          make_body() {
            local owner="$1" repo="$2" def_branch="$3" last_def="$4" stale_days="$5" diverges="$6" stale="$7" hash="$8"
            cat <<EOF
Detected repo-health issues:

- **Diverges from default**: ${diverges}
- **Default branch stale (> ${stale_days} days)**: ${stale}

**Default branch**: \`${def_branch:-"(none)"}\`  
**Last default commit**: \`${last_def:-"(none)"}\`

Remediation checklist:
- [ ] Review recent branches and merge or retarget default as needed
- [ ] If divergence is expected (e.g., long-lived release), document it or add a topic to ignore
- [ ] If repo is intentionally frozen, archive it or add \`repo-health:ignore\` topic

<!-- repo-health-fp: ${owner}/${repo} -->
<!-- repo-health-hash: ${hash} -->
EOF
          }

          sha_payload() {
            local owner="$1" repo="$2" def_branch="$3" last_def="$4" diverges="$5" stale="$6" stale_days="$7"
            printf '%s' "$owner|$repo|$def_branch|$last_def|$diverges|$stale|$stale_days" | sha256sum | awk '{print $1}'
          }

          title="[Repo Health] Default branch stale/diverges"

          jq -c '.items[]' violations.json | while read -r it; do
            owner=$(jq -r '.owner' <<<"$it")
            repo=$(jq -r '.repo' <<<"$it")
            def_branch=$(jq -r '.default_branch' <<<"$it")
            last_def=$(jq -r '.last_default' <<<"$it")
            diverges=$(jq -r '.diverges' <<<"$it")
            stale=$(jq -r '.stale_default' <<<"$it")
            hash=$(sha_payload "$owner" "$repo" "$def_branch" "$last_def" "$diverges" "$stale" "$STALE_DAYS")
            body="$(make_body "$owner" "$repo" "$def_branch" "$last_def" "$STALE_DAYS" "$diverges" "$stale" "$hash")"

            # find existing (state=all) by fingerprint; fallback to exact title
            existing_json=$(gh api "/repos/$owner/$repo/issues" -f per_page=100 -f state=all \
              -q '[.[] | select(.body != null and (.body | contains("repo-health-fp: '"$owner/$repo"'")))]')
            if [ "$(jq 'length' <<<"$existing_json")" -eq 0 ]; then
              existing_json=$(gh api "/repos/$owner/$repo/issues" -f per_page=100 -f state=all \
                -q '.[] | select(.title=="'"$title"'") | [.]')
            fi

            if [ "$(jq 'length' <<<"$existing_json")" -gt 0 ]; then
              num=$(jq -r '.[0].number' <<<"$existing_json")
              state=$(jq -r '.[0].state' <<<"$existing_json")
              existing_body=$(jq -r '.[0].body // ""' <<<"$existing_json")
              prev_hash=$(grep -oE 'repo-health-hash: [a-f0-9]+' <<<"$existing_body" | awk '{print $3}' || true)

              if [ "$state" = "closed" ] && [ "$REOPEN_CLOSED" = "true" ]; then
                gh api -X PATCH "/repos/$owner/$repo/issues/$num" -f state="open" >/dev/null
              fi

              if [ "$prev_hash" != "$hash" ]; then
                gh api -X PATCH "/repos/$owner/$repo/issues/$num" \
                  -f title="$title" -f body="$body" -f labels="repo-health" >/dev/null
                echo "Updated issue #$num in $owner/$repo"
              else
                echo "No changes for $owner/$repo (issue #$num)"
              fi
            else
              gh api -X POST "/repos/$owner/$repo/issues" \
                -f title="$title" -f body="$body" -f labels="repo-health" >/dev/null
              echo "Created issue in $owner/$repo"
            fi
          done

      - name: Auto-comment & close issues for repos now clean
        env:
          GH_TOKEN: ${{ env.GH_TOKEN_EFFECTIVE }}
        run: |
          set -euo pipefail
          jq -r '.ids[]?' violations.json > violating_ids.txt || true

          # ✅ FIX: Correct jq path (no space) for __owner
          jq -r '.[] | "\(..__owner)/\(.name)"' repos_filtered.json > all_ids.txt

          while read -r id; do
            [ -z "$id" ] && continue
            if grep -qx "$id" violating_ids.txt 2>/dev/null; then
              continue
            fi
            owner="${id%%/*}"
            repo="${id##*/}"

            open_json=$(gh api "/repos/$owner/$repo/issues" -f per_page=100 -f state=open \
              -q '[.[] | select((.body != null and (.body | contains("repo-health-fp: '"$owner/$repo"'"))) or .title=="[Repo Health] Default branch stale/diverges")]')

            count=$(jq 'length' <<<"$open_json")
            [ "$count" -eq 0 ] && continue

            num=$(jq -r '.[0].number' <<<"$open_json")
            comment="✅ This repository is now **clean** for the monitored checks (no divergence and default branch not stale). Closing this issue automatically."
            gh api -X POST "/repos/$owner/$repo/issues/$num/comments" -f body="$comment" >/dev/null
            gh api -X PATCH "/repos/$owner/$repo/issues/$num" -f state="closed" >/dev/null
            echo "Closed issue #$num in $owner/$repo (now clean)"
          done < all_ids.txt

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: repo-health-${{ github.run_id }}
          path: reports/${{ github.run_id }}/
          if-no-files-found: error

      - name: Fail on critical (optional)
        if: ${{ env.FAIL_ON_CRITICAL == 'true' }}
        run: |
          set -euo pipefail
          v=$(jq -r .count violations.json)
          if [ "$v" -gt 0 ]; then
            echo "Found $v violating repos."
            exit 1
          fi